import argparse
import re

signal_re = re.compile("(input|output) (\\[(\\d+):(\\d+)\\] )?(\\w+);")

argparser = argparse.ArgumentParser(prog="synth_post", description = "Generates wrapper subckt for yosys spice extraction")
argparser.add_argument("input_spice_file", type=str, help="Path to Yosys generated spice")
argparser.add_argument("input_verilog_file", type=str, help="Path to Yosys generated verilog")
argparser.add_argument("process_path", type=str, help="Path to pdk transistor library")
argparser.add_argument("process_corner", type=str, help="Process corner")
argparser.add_argument("library_path", type=str, help="Path to pdk cell library")
argparser.add_argument("output_file", type=str, help="Path to generate output file")

args = argparser.parse_args()

subckt_name = args.output_file.split(".")[0]

# Helpers ---------------------------------------------------

def get_num_outputs(model):
    if model == "sky130_fd_sc_hs__fahcon_1":
        return 2
    if "bp" in model and model != "sky130_fd_sc_hs__sdfbbp_1":
        return 2
    return 1

PG_PINS = ["VGND","VNB","VPB","VPWR"]

# -----------------------------------------------------------

# Read important info (eg circuit naame, net names)
inputs = []
outputs = []

with open(args.input_verilog_file, "r") as file:
    for line in file.readlines():
        line = line.strip()

        if match:=signal_re.match(line):
            io, _, start, end, name = match.groups()

            if start is None:
                signals = [name]
            else:
                start = int(start)
                end = int(end)
                if (start > end): start, end = end, start
                signals = [f"{name}.{i}" for i in range(start, end+1)]

            if io == "input":
                inputs += signals
            else:
                outputs += signals

# Read list of modules required to load

models = set()
model_files = []
spice_lines = []

with open(args.input_spice_file, "r") as file:
    for line in file.readlines():
        line = line.lower().strip()
        if line.startswith("x"):
            split = line.split(" ")
            model = split[-1]

            if model not in models:
                sublib, cell = model.split("__")
                name, id = cell.split("_")
                device = "_".join
                mfile = f"{args.library_path}/cells/{name}/{sublib}__{cell}.spice"
                model_files.append(mfile)
                models.add(model)

            num_out = get_num_outputs(model)
            split = split[:-1-num_out] + PG_PINS + split[-1-num_out:]
            spice_lines.append(" ".join(split)) 
        elif line.startswith("*"): continue
        else:
            spice_lines.append(line)

# Write wrapper spice model

with open(args.output_file, "w") as file:
    file.write(f"{subckt_name}\n")
    file.write("* File Autogenerated by synth_post.py\n\n")
    file.write(f'.lib "{args.process_path}" {args.process_corner}\n')

    for model in models:
        #process, make, type, category, *device = model.split("_")
        sublib, cell = model.split("__")
        name, id = cell.split("_")
        device = "_".join

        #file.write(f".include {args.library_path}/{sublib}/latest/cells/{name}/{sublib}__{cell}.spice\n")
        file.write(f".include {args.library_path}/cells/{name}/{sublib}__{cell}.spice\n")

    file.write(f"\n.subckt {subckt_name} {' '.join([x for x in inputs])} {' '.join([x for x in PG_PINS])} {' '.join([x for x in outputs])}\n")
    #file.write(f".include {args.input_spice_file}\n")
    for line in spice_lines: file.write(line + "\n")
    file.write(f".ends\n\n")

